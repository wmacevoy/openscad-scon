#!/usr/bin/env qjs
import * as std from 'std';

// ——— SCON‑escaping functions ———
function sconChar(ch) {
  const cp = ch.codePointAt(0);
  if (cp >= 32 && cp <= 127) {
    if (ch === '\\') return '\\\\';
    if (ch === '"')  return '\\"';
    return ch;
  }
  if (cp <= 0xFF) {
    if (ch === '\n') return '\\n';
    if (ch === '\r') return '\\r';
    if (ch === '\t') return '\\t';
    return '\\x' + cp.toString(16).padStart(2, '0');
  }
  if (cp <= 0xFFFF) {
    return '\\u' + cp.toString(16).padStart(4, '0');
  }
  return '\\U' + cp.toString(16).padStart(8, '0');
}

function sconString(s) {
  let out = '';
  for (const ch of s) out += sconChar(ch);
  return `"${out}"`;
}

function sconFromJson(data) {
  if (data === null)       return 'undef';
  if (Array.isArray(data)) return '[' + data.map(sconFromJson).join(', ') + ']';
  if (typeof data === 'object') {
    const items = [];
    for (const [k, v] of Object.entries(data)) {
      items.push(`[${sconString(k)}, ${sconFromJson(v)}]`);
    }
    return '[' + items.join(', ') + ']';
  }
  if (typeof data === 'string')  return sconString(data);
  if (typeof data === 'boolean') return data ? 'true' : 'false';
  return String(data);
}

function readAll() {
    let lines = [];
    for (;;) {
        let line = std.in.getline();
        if (line === null) break;
        lines.push(line);
    }
    return lines.join("\n");
}

let fmt = "{scon}";
for (let i = 1; i < scriptArgs.length; i++) {
  const arg = scriptArgs[i];
  if (arg.startsWith('--fmt=')) {
    fmt = arg.slice(6);
  } else if (arg === '--fmt' && i + 1 < scriptArgs.length) {
    fmt = scriptArgs[++i];
  }
}

const jsonStr=readAll();

let data;
try {
  data = JSON.parse(jsonStr);
} catch (e) {
  std.err.write('Failed to decode JSON from input.\n');
  std.exit(1);
}
const scon = sconFromJson(data);
console.log(fmt.replace('{scon}', scon));
